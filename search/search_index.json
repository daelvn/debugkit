{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"debugkit \u00b6 Print debugging made easier. Why? \u00b6 We all know what happens when we have to debug our code. Most of the times, we don't use a full-fledged Lua debugger, and don't even think about it if you are using MoonScript. What happens is that we end up putting print statements in the part of the code that we guess the error is happening. Now, this usually solves most of our issues if our library is small, but if our library is gigantic, all you're going to get is a lot of unordered printed tables and values. One approach I take is prefixing them with a word or tag, but then I would need a custom function to filter them out which was janky at best. I didn't want to add and remove messages. I didn't want to get lost in a sea of all-white values. I needed something practical. That is all very good, there are many logger libraries out there to help me. So, why did I decide to make my own? If you told me I had NHI Syndrome , I would probably agree with you, but I don't think that is the reason. I've been looking at other libraries, and some were old, some were oriented for time logging, some weren't as flexible... If I kept dwelling, eventually I would have found one, but something powerful didn't seem to pop up that fast. What I made here is some kind of framework. Even though I would very happily add features to the repo such as better stack traces, printing locals, etc. if anyone PR'ed them, there is none of that. This gives you mainly two concepts, a logger and a sink. All around is just helper tools or functions. You can extend those two concepts to make amazing stuff. Hell, you could even submit logging results via HTTP if you wanted. But I just wanna ~~grill~~ print! Or simply you just need a logger. How? \u00b6 Install the library using LuaRocks, and if I can be arsed in the future, my own Lua package manager that hopefully does not want to make me go live in a forest all by myself. $ luarocks install debugkit That will automatically install all dependencies. If that is not the case for some reason, do: $ luarocks install filekit $ luarocks install guardia And if you want to use the JSON sink in debugkit.log.sinks , install any of dkjson , lua-cjson2 or rxi-json-lua . I've personally tested it under cjson , but all of them should work the same. If you want to use the colorized inspect function in debugkit.inspect , you will need lrexlib-pcre2 . The strings are not precisely easy to color without them. The documentation is availiable at https://git.daelvn.ga/debugkit. When? \u00b6 Ideally when you need to debug, or log something. Perhaps if you want a pretty inspect function. Otherwise... what? Who? \u00b6 Dael Mu\u00f1iz daelvn@gmail.com I am so sorry if you can't type the \u00f1, I agree that I shouldn't have been born Spanish. Feel free to use \"Muniz\". License \u00b6 Throwing this to the public domain. Steal it for all I care. Goodbye? \u00b6 Goodbye.","title":"Home"},{"location":"#debugkit","text":"Print debugging made easier.","title":"debugkit"},{"location":"#why","text":"We all know what happens when we have to debug our code. Most of the times, we don't use a full-fledged Lua debugger, and don't even think about it if you are using MoonScript. What happens is that we end up putting print statements in the part of the code that we guess the error is happening. Now, this usually solves most of our issues if our library is small, but if our library is gigantic, all you're going to get is a lot of unordered printed tables and values. One approach I take is prefixing them with a word or tag, but then I would need a custom function to filter them out which was janky at best. I didn't want to add and remove messages. I didn't want to get lost in a sea of all-white values. I needed something practical. That is all very good, there are many logger libraries out there to help me. So, why did I decide to make my own? If you told me I had NHI Syndrome , I would probably agree with you, but I don't think that is the reason. I've been looking at other libraries, and some were old, some were oriented for time logging, some weren't as flexible... If I kept dwelling, eventually I would have found one, but something powerful didn't seem to pop up that fast. What I made here is some kind of framework. Even though I would very happily add features to the repo such as better stack traces, printing locals, etc. if anyone PR'ed them, there is none of that. This gives you mainly two concepts, a logger and a sink. All around is just helper tools or functions. You can extend those two concepts to make amazing stuff. Hell, you could even submit logging results via HTTP if you wanted. But I just wanna ~~grill~~ print! Or simply you just need a logger.","title":"Why?"},{"location":"#how","text":"Install the library using LuaRocks, and if I can be arsed in the future, my own Lua package manager that hopefully does not want to make me go live in a forest all by myself. $ luarocks install debugkit That will automatically install all dependencies. If that is not the case for some reason, do: $ luarocks install filekit $ luarocks install guardia And if you want to use the JSON sink in debugkit.log.sinks , install any of dkjson , lua-cjson2 or rxi-json-lua . I've personally tested it under cjson , but all of them should work the same. If you want to use the colorized inspect function in debugkit.inspect , you will need lrexlib-pcre2 . The strings are not precisely easy to color without them. The documentation is availiable at https://git.daelvn.ga/debugkit.","title":"How?"},{"location":"#when","text":"Ideally when you need to debug, or log something. Perhaps if you want a pretty inspect function. Otherwise... what?","title":"When?"},{"location":"#who","text":"Dael Mu\u00f1iz daelvn@gmail.com I am so sorry if you can't type the \u00f1, I agree that I shouldn't have been born Spanish. Feel free to use \"Muniz\".","title":"Who?"},{"location":"#license","text":"Throwing this to the public domain. Steal it for all I care.","title":"License"},{"location":"#goodbye","text":"Goodbye.","title":"Goodbye?"},{"location":"manual/basics/","text":"debugkit Basics \u00b6 This manual covers the basics of logging and inspecting using debugkit. Inspecting \u00b6 There is not much to this, you simply import the function and use it exactly the same way as you would with inspect.lua . Lua inspect = require \"debugkit.inspect\" . inspect print ( inspect ( t )) MoonScript import inspect from require \" debugkit.inspect \" print inspect t Logging \u00b6 Getting Started \u00b6 Logging is a bit more complex. For a simple task such as the usual print debugging, you might just want to use the minimal logger. Lua logger = require \"debugkit.log\" . logger myLogger = logger . minimal () myLogger . level = \"all\" log = myLogger \"all\" log ( \"tag\" , \"msg\" ) MoonScript import logger from require \" debugkit.log \" myLogger = logger . minimal ! myLogger . level = \" all \" log = myLogger \" all \" log \" msg \" This works if you're print-debugging. However, if you need actual logging with time, levels, tags. That will not suffice. Headers and footers \u00b6 Before anything else, you will want to know how headers and footers work for properly printing messages (or logging them into a file). These are obtained by the logger by calling self : header () and self : footer () (or @header! and @footer! if you are using MoonScript) from within the Logger function. They must be functions so things like setting the level, time and date work. Let's look at the definition of a header. Lua logger . example = function () return Logger { header = function ( self , tag , level ) return ( \"%s %s [%s]\" ): format self . time (), self . name , level end } end MoonScript logger . example = -> Logger header: ( tag , level ) => \" #{@time!} #{@name} [#{level}] \" Note Footers work exactly the same way, getting passed self, tag and level. As we can see, the header function takes the header itself and the level for the message, and then returns a formatted string. It calls time so that it returns a different time each time. time is defined as: Lua logger . example = function () return Logger { time = function ( self ) return os.date \"%X\" end } end MoonScript logger . example = -> Logger time: => os.date \" %X \" Now, you might want to make your header depend on the level being used, say, for coloring differently. Let's check the definition in the loggers module. Lua -- leveled logger logger . leveled = function () return Logger ({ headers = { base = function ( self ) return self . color and ( style ( \"%{white bold}\" .. tostring ( self : time ()) .. \" %{green}\" .. tostring ( self . name ) .. \" \" )) or tostring ( self : time ()) .. \" \" .. tostring ( self . name ) end , levels = { none = function ( self ) return self . color and (( style . white ( \"[NONE]\" )) .. ( style . reset ( \" \" ))) or \"[NONE] \" end , debug = function ( self ) return self . color and (( style . white . bluebg ( \"[DEBUG]\" )) .. ( style . reset ( \" \" ))) or \"[DEBUG]\" end , info = function ( self ) return self . color and (( style . cyan ( \"[INFO]\" )) .. ( style . reset ( \" \" ))) or \"[INFO] \" end , ok = function ( self ) return self . color and (( style . green ( \"[OK]\" )) .. ( style . reset ( \" \" ))) or \"[OK] \" end , warn = function ( self ) return self . color and (( style . yellow ( \"[WARN]\" )) .. ( style . reset ( \" \" ))) or \"[WARN] \" end , error = function ( self ) return self . color and (( style . red ( \"[ERROR]\" )) .. ( style . reset ( \" \" ))) or \"[ERROR]\" end , fatal = function ( self ) return self . color and (( style . white . redbg ( \"[FATAL]\" )) .. ( style . reset ( \" \" ))) or \"[FATAL]\" end , all = function ( self ) return self . color and (( style . black . whitebg ( \"[ALL]\" )) .. ( style . reset ( \" \" ))) or \"[ALL] \" end } }, header = function ( self , level ) return ( self . headers . base ( self )) .. ( self . headers . levels [ level ]( self )) end }) end MoonScript -- Leveled logger logger . leveled = -> Logger { headers: { base: => @color and ( style \" %{white bold}#{@time!} %{green}#{@name} \" ) or \" #{@time!} #{@name} \" levels: none: => @color and (( style . white \" [NONE] \" ) .. ( style . reset \" \" )) or \" [NONE] \" debug: => @color and (( style . white . bluebg \" [DEBUG] \" ) .. ( style . reset \" \" )) or \" [DEBUG] \" info: => @color and (( style . cyan \" [INFO] \" ) .. ( style . reset \" \" )) or \" [INFO] \" ok: => @color and (( style . green \" [OK] \" ) .. ( style . reset \" \" )) or \" [OK] \" warn: => @color and (( style . yellow \" [WARN] \" ) .. ( style . reset \" \" )) or \" [WARN] \" error: => @color and (( style . red \" [ERROR] \" ) .. ( style . reset \" \" )) or \" [ERROR] \" fatal: => @color and (( style . white . redbg \" [FATAL] \" ) .. ( style . reset \" \" )) or \" [FATAL] \" all: => @color and (( style . black . whitebg \" [ALL] \" ) .. ( style . reset \" \" )) or \" [ALL] \" } header: ( tag , level ) => ( @headers . base @ ) .. ( @headers . levels [ level ] @ ) } It is pretty much self-explanatory. The logger calls header , and this uses a base in the table headers and a level from headers.levels . That is a way of making changing headers, but you can customize it as you wish. Tags \u00b6 Tags are a really simple concept that allow you to exclude and filter messages depending on their \"topic\". For example, I am logging two things at debug level, one is about strings and the other about numbers. If I am debugging numbers, I will only want to know about the number messages. Loggers let you prefix a tag to your message, like log(\"tag\", \"msg\") , and using a table in the logger, exclude , you can filter out the messages that are in the table exclude . So I would do: myLogger . exclude = { \"string\" } log = myLogger \"debug\" log ( \"string\" , \"will not print\" ) log ( \"number\" , \"will print\" ) And now it will only print the second message. Levels \u00b6 Levels are the way of filtering out whole categories of messages. logger.leveled has 7: none debug info ok warn error fatal all These are in order, from least important to most important. Using the function levels , you can pass it an ordered list of levels and you will get a reversed table back ( keys become values, values become keys), making each level a certain number. Now, when you log a message with a level, it checks its number , and the sink (usually) will only print if the message level is equal or superior to the minimum level (set in Logger.level ). Sinks \u00b6 You can use a different sink with a logger just by changing the Logger.sink component. For example, I can make logger.leveled print JSON strings doing: myLogger = logger . minimal () myLogger . sink = sink . json () log = myLogger () It's really simple and works on the fly, but if you change the sink after it has been opened, you will need to close the previous one, then change it, then open it manually again, like this: Lua myLogger : close () myLogger . sink = sink . file \"example.log\" myLogger : open () MoonScript myLogger \\ close ! myLogger . sink = sink . file \" example.log \" myLogger \\ open ! Not all sinks need to be opened, but you won't get an error from trying to open one which doesn't have an open method, or from trying to close one which doesn't have a close method.","title":"Basics"},{"location":"manual/basics/#debugkit-basics","text":"This manual covers the basics of logging and inspecting using debugkit.","title":"debugkit Basics"},{"location":"manual/basics/#inspecting","text":"There is not much to this, you simply import the function and use it exactly the same way as you would with inspect.lua . Lua inspect = require \"debugkit.inspect\" . inspect print ( inspect ( t )) MoonScript import inspect from require \" debugkit.inspect \" print inspect t","title":"Inspecting"},{"location":"manual/basics/#logging","text":"","title":"Logging"},{"location":"manual/basics/#getting-started","text":"Logging is a bit more complex. For a simple task such as the usual print debugging, you might just want to use the minimal logger. Lua logger = require \"debugkit.log\" . logger myLogger = logger . minimal () myLogger . level = \"all\" log = myLogger \"all\" log ( \"tag\" , \"msg\" ) MoonScript import logger from require \" debugkit.log \" myLogger = logger . minimal ! myLogger . level = \" all \" log = myLogger \" all \" log \" msg \" This works if you're print-debugging. However, if you need actual logging with time, levels, tags. That will not suffice.","title":"Getting Started"},{"location":"manual/basics/#headers-and-footers","text":"Before anything else, you will want to know how headers and footers work for properly printing messages (or logging them into a file). These are obtained by the logger by calling self : header () and self : footer () (or @header! and @footer! if you are using MoonScript) from within the Logger function. They must be functions so things like setting the level, time and date work. Let's look at the definition of a header. Lua logger . example = function () return Logger { header = function ( self , tag , level ) return ( \"%s %s [%s]\" ): format self . time (), self . name , level end } end MoonScript logger . example = -> Logger header: ( tag , level ) => \" #{@time!} #{@name} [#{level}] \" Note Footers work exactly the same way, getting passed self, tag and level. As we can see, the header function takes the header itself and the level for the message, and then returns a formatted string. It calls time so that it returns a different time each time. time is defined as: Lua logger . example = function () return Logger { time = function ( self ) return os.date \"%X\" end } end MoonScript logger . example = -> Logger time: => os.date \" %X \" Now, you might want to make your header depend on the level being used, say, for coloring differently. Let's check the definition in the loggers module. Lua -- leveled logger logger . leveled = function () return Logger ({ headers = { base = function ( self ) return self . color and ( style ( \"%{white bold}\" .. tostring ( self : time ()) .. \" %{green}\" .. tostring ( self . name ) .. \" \" )) or tostring ( self : time ()) .. \" \" .. tostring ( self . name ) end , levels = { none = function ( self ) return self . color and (( style . white ( \"[NONE]\" )) .. ( style . reset ( \" \" ))) or \"[NONE] \" end , debug = function ( self ) return self . color and (( style . white . bluebg ( \"[DEBUG]\" )) .. ( style . reset ( \" \" ))) or \"[DEBUG]\" end , info = function ( self ) return self . color and (( style . cyan ( \"[INFO]\" )) .. ( style . reset ( \" \" ))) or \"[INFO] \" end , ok = function ( self ) return self . color and (( style . green ( \"[OK]\" )) .. ( style . reset ( \" \" ))) or \"[OK] \" end , warn = function ( self ) return self . color and (( style . yellow ( \"[WARN]\" )) .. ( style . reset ( \" \" ))) or \"[WARN] \" end , error = function ( self ) return self . color and (( style . red ( \"[ERROR]\" )) .. ( style . reset ( \" \" ))) or \"[ERROR]\" end , fatal = function ( self ) return self . color and (( style . white . redbg ( \"[FATAL]\" )) .. ( style . reset ( \" \" ))) or \"[FATAL]\" end , all = function ( self ) return self . color and (( style . black . whitebg ( \"[ALL]\" )) .. ( style . reset ( \" \" ))) or \"[ALL] \" end } }, header = function ( self , level ) return ( self . headers . base ( self )) .. ( self . headers . levels [ level ]( self )) end }) end MoonScript -- Leveled logger logger . leveled = -> Logger { headers: { base: => @color and ( style \" %{white bold}#{@time!} %{green}#{@name} \" ) or \" #{@time!} #{@name} \" levels: none: => @color and (( style . white \" [NONE] \" ) .. ( style . reset \" \" )) or \" [NONE] \" debug: => @color and (( style . white . bluebg \" [DEBUG] \" ) .. ( style . reset \" \" )) or \" [DEBUG] \" info: => @color and (( style . cyan \" [INFO] \" ) .. ( style . reset \" \" )) or \" [INFO] \" ok: => @color and (( style . green \" [OK] \" ) .. ( style . reset \" \" )) or \" [OK] \" warn: => @color and (( style . yellow \" [WARN] \" ) .. ( style . reset \" \" )) or \" [WARN] \" error: => @color and (( style . red \" [ERROR] \" ) .. ( style . reset \" \" )) or \" [ERROR] \" fatal: => @color and (( style . white . redbg \" [FATAL] \" ) .. ( style . reset \" \" )) or \" [FATAL] \" all: => @color and (( style . black . whitebg \" [ALL] \" ) .. ( style . reset \" \" )) or \" [ALL] \" } header: ( tag , level ) => ( @headers . base @ ) .. ( @headers . levels [ level ] @ ) } It is pretty much self-explanatory. The logger calls header , and this uses a base in the table headers and a level from headers.levels . That is a way of making changing headers, but you can customize it as you wish.","title":"Headers and footers"},{"location":"manual/basics/#tags","text":"Tags are a really simple concept that allow you to exclude and filter messages depending on their \"topic\". For example, I am logging two things at debug level, one is about strings and the other about numbers. If I am debugging numbers, I will only want to know about the number messages. Loggers let you prefix a tag to your message, like log(\"tag\", \"msg\") , and using a table in the logger, exclude , you can filter out the messages that are in the table exclude . So I would do: myLogger . exclude = { \"string\" } log = myLogger \"debug\" log ( \"string\" , \"will not print\" ) log ( \"number\" , \"will print\" ) And now it will only print the second message.","title":"Tags"},{"location":"manual/basics/#levels","text":"Levels are the way of filtering out whole categories of messages. logger.leveled has 7: none debug info ok warn error fatal all These are in order, from least important to most important. Using the function levels , you can pass it an ordered list of levels and you will get a reversed table back ( keys become values, values become keys), making each level a certain number. Now, when you log a message with a level, it checks its number , and the sink (usually) will only print if the message level is equal or superior to the minimum level (set in Logger.level ).","title":"Levels"},{"location":"manual/basics/#sinks","text":"You can use a different sink with a logger just by changing the Logger.sink component. For example, I can make logger.leveled print JSON strings doing: myLogger = logger . minimal () myLogger . sink = sink . json () log = myLogger () It's really simple and works on the fly, but if you change the sink after it has been opened, you will need to close the previous one, then change it, then open it manually again, like this: Lua myLogger : close () myLogger . sink = sink . file \"example.log\" myLogger : open () MoonScript myLogger \\ close ! myLogger . sink = sink . file \" example.log \" myLogger \\ open ! Not all sinks need to be opened, but you won't get an error from trying to open one which doesn't have an open method, or from trying to close one which doesn't have a close method.","title":"Sinks"},{"location":"module/inspect/","text":"debugkit.inspect \u00b6 Simple colorizing for inspect.lua using lrexlib-pcre2 as a regex library (although only needed for matching strings correctly) and ansikit . inspect \u00b6 Clone of the inspect function in inspect.lua , except it colorizes the output. It colors strings in green, tags in <> in cyan, numbers in magenta, = in bold blue, { and } in bold white. true in italics green and false in italics red. Metamethods in italics and indentation adds guides in faint white.","title":"debugkit.inspect"},{"location":"module/inspect/#debugkitinspect","text":"Simple colorizing for inspect.lua using lrexlib-pcre2 as a regex library (although only needed for matching strings correctly) and ansikit .","title":"debugkit.inspect"},{"location":"module/inspect/#inspect","text":"Clone of the inspect function in inspect.lua , except it colorizes the output. It colors strings in green, tags in <> in cyan, numbers in magenta, = in bold blue, { and } in bold white. true in italics green and false in italics red. Metamethods in italics and indentation adds guides in faint white.","title":"inspect"},{"location":"module/log/init/","text":"debugkit.log.init \u00b6 A logger module, introducing the concept of sinks and loggers. Sinks \u00b6 Sinks are interfaces that get logger messages and turn them into another representation. Sinks can output to stdout, files, databases, networks... and anything you want, as long as you code it of course. Components \u00b6 flag : (table) flags for the sink. open : (function) function that opens the sink. write : (function) function that writes a message to the sink. close : (function) function that closes the sink. Loggers \u00b6 Loggers produce the messages to be passed to the sinks. They feature levels and tags which the sinks can filter out. They are pretty much self-explanatory. The sink is opened when the function returned by Logger is called. Components \u00b6 color : (boolean) whether to use color or not. name : (string) name of the app. sink : (Sink) sink to use with the logger. level : (string) current logging filter. rejects all below. levels : (table) using levels , the list of levels availiable, from least important to most important. time : (function) called with self, must return time. date : (function) called with self, must return date. header : (function) called with self, must return a header for the message. footer : (function) called with self, must return a footer for the message. exclude : (table) unordered list of tags to filter out. open : (function) calls Logger.sink.open(Logger.sink) . close : (function) calls Logger.sink.close(Logger.sink) . Sink \u00b6 Signature -> table -> Sink Takes a table with any components (all are optional but you will probably want to pass write , at least). Logger \u00b6 Signature -> table -> Logger Takes a table with any components (all are optional, and if none are passed, it will automatically create a working minimal logger practically equivalent to logger.default in no color mode). The returned Logger can be called again and has the following signature level : string -> [ tag : string ], msg : string -> nil . It first takes a level, and generates a function that only posts to that level so it can be filtered. This is where the sink is opened, and using flags you can make sure it doesnt get opened more than once. Then, it takes an optional tag for filtering and a message. List of sinks \u00b6 All bellow return the sink only when called. sink.null \u00b6 Doesn't do absolutely anything. sink.all \u00b6 Prints all messages with print , regardless of level or tag. sink.print \u00b6 Prints all messages with print , looking at level and tags. sink.write \u00b6 Prints all messages with io.write , looking at level and tags. sink.file \u00b6 Takes a filename and returns a sink that writes to that file, looking at level and tags. List of loggers \u00b6 All below return the logger only when called. logger.minimal \u00b6 Produces messages with a count of times logged, nothing else. Color is availiable. It has the rest of components, levels and tags from default , etc. This logger is not meant to use them, but you may. 1 $ test string 2 $ this is how it looks like logger.default \u00b6 Default logger. name : default sink : sink.write level : all levels : none , all time : os.date \"%X\" date : \"\" color : true footer : \\n header : %{white bold}#{@time!} %{green}#{@name} with possibility to omit colors.","title":"debugkit.log.init"},{"location":"module/log/init/#debugkitloginit","text":"A logger module, introducing the concept of sinks and loggers.","title":"debugkit.log.init"},{"location":"module/log/init/#sinks","text":"Sinks are interfaces that get logger messages and turn them into another representation. Sinks can output to stdout, files, databases, networks... and anything you want, as long as you code it of course.","title":"Sinks"},{"location":"module/log/init/#components","text":"flag : (table) flags for the sink. open : (function) function that opens the sink. write : (function) function that writes a message to the sink. close : (function) function that closes the sink.","title":"Components"},{"location":"module/log/init/#loggers","text":"Loggers produce the messages to be passed to the sinks. They feature levels and tags which the sinks can filter out. They are pretty much self-explanatory. The sink is opened when the function returned by Logger is called.","title":"Loggers"},{"location":"module/log/init/#components_1","text":"color : (boolean) whether to use color or not. name : (string) name of the app. sink : (Sink) sink to use with the logger. level : (string) current logging filter. rejects all below. levels : (table) using levels , the list of levels availiable, from least important to most important. time : (function) called with self, must return time. date : (function) called with self, must return date. header : (function) called with self, must return a header for the message. footer : (function) called with self, must return a footer for the message. exclude : (table) unordered list of tags to filter out. open : (function) calls Logger.sink.open(Logger.sink) . close : (function) calls Logger.sink.close(Logger.sink) .","title":"Components"},{"location":"module/log/init/#sink","text":"Signature -> table -> Sink Takes a table with any components (all are optional but you will probably want to pass write , at least).","title":"Sink"},{"location":"module/log/init/#logger","text":"Signature -> table -> Logger Takes a table with any components (all are optional, and if none are passed, it will automatically create a working minimal logger practically equivalent to logger.default in no color mode). The returned Logger can be called again and has the following signature level : string -> [ tag : string ], msg : string -> nil . It first takes a level, and generates a function that only posts to that level so it can be filtered. This is where the sink is opened, and using flags you can make sure it doesnt get opened more than once. Then, it takes an optional tag for filtering and a message.","title":"Logger"},{"location":"module/log/init/#list-of-sinks","text":"All bellow return the sink only when called.","title":"List of sinks"},{"location":"module/log/init/#sinknull","text":"Doesn't do absolutely anything.","title":"sink.null"},{"location":"module/log/init/#sinkall","text":"Prints all messages with print , regardless of level or tag.","title":"sink.all"},{"location":"module/log/init/#sinkprint","text":"Prints all messages with print , looking at level and tags.","title":"sink.print"},{"location":"module/log/init/#sinkwrite","text":"Prints all messages with io.write , looking at level and tags.","title":"sink.write"},{"location":"module/log/init/#sinkfile","text":"Takes a filename and returns a sink that writes to that file, looking at level and tags.","title":"sink.file"},{"location":"module/log/init/#list-of-loggers","text":"All below return the logger only when called.","title":"List of loggers"},{"location":"module/log/init/#loggerminimal","text":"Produces messages with a count of times logged, nothing else. Color is availiable. It has the rest of components, levels and tags from default , etc. This logger is not meant to use them, but you may. 1 $ test string 2 $ this is how it looks like","title":"logger.minimal"},{"location":"module/log/init/#loggerdefault","text":"Default logger. name : default sink : sink.write level : all levels : none , all time : os.date \"%X\" date : \"\" color : true footer : \\n header : %{white bold}#{@time!} %{green}#{@name} with possibility to omit colors.","title":"logger.default"},{"location":"module/log/loggers/","text":"debugkit.log.loggers \u00b6 All below return the logger when called. leveled \u00b6 name : leveled sink : sink.print level : info levels : none , debug , info , ok , warn , error , fatal , all time : os.date \"%X\" date : \"\" color : true footer : `` Header \u00b6 The header is formed from a non-standard component named headers . headers is a table that contains a function base which acts as the non-changing part of the header (time, name...) and a table of functions levels with one function per level that adds a header in the style of [ LEVEL ] . Feel free to mess around with it to know the colors for each one. From the logger, header is called with self and the level of the message, and it assembles both parts together.","title":"debugkit.log.loggers"},{"location":"module/log/loggers/#debugkitlogloggers","text":"All below return the logger when called.","title":"debugkit.log.loggers"},{"location":"module/log/loggers/#leveled","text":"name : leveled sink : sink.print level : info levels : none , debug , info , ok , warn , error , fatal , all time : os.date \"%X\" date : \"\" color : true footer : ``","title":"leveled"},{"location":"module/log/loggers/#header","text":"The header is formed from a non-standard component named headers . headers is a table that contains a function base which acts as the non-changing part of the header (time, name...) and a table of functions levels with one function per level that adds a header in the style of [ LEVEL ] . Feel free to mess around with it to know the colors for each one. From the logger, header is called with self and the level of the message, and it assembles both parts together.","title":"Header"},{"location":"module/log/sinks/","text":"debugkit.log.sinks \u00b6 All below return the sink when called. json \u00b6 Returns all data from the logger and sink as a JSON string. Encoded using any of the optional dependency JSON libraries. Exports logger name, level filter, time, date, excluding tags and flags in a table named data , and in the top level, the message, level of the message, and the tag. rollingFile \u00b6 Taking a filename and a size in bytes (defaults to 1000000), creates a sink that will automatically start writing in another file ( (filename).(count) except for the first one, which is just filename ) after the file is deemed full.","title":"debugkit.log.sinks"},{"location":"module/log/sinks/#debugkitlogsinks","text":"All below return the sink when called.","title":"debugkit.log.sinks"},{"location":"module/log/sinks/#json","text":"Returns all data from the logger and sink as a JSON string. Encoded using any of the optional dependency JSON libraries. Exports logger name, level filter, time, date, excluding tags and flags in a table named data , and in the top level, the message, level of the message, and the tag.","title":"json"},{"location":"module/log/sinks/#rollingfile","text":"Taking a filename and a size in bytes (defaults to 1000000), creates a sink that will automatically start writing in another file ( (filename).(count) except for the first one, which is just filename ) after the file is deemed full.","title":"rollingFile"}]}